"""AnkiConnect Adapter."""

import logging
import shutil
from pathlib import Path

from ankiops.anki_client import AnkiConnectError, invoke
from ankiops.models import (
    AnkiNote,
    Change,
    ChangeType,
    NoteTypeConfig,
)

logger = logging.getLogger(__name__)

# Editor-side field properties (set via AnkiConnect)
FIELD_FONT_SIZES = {
    "Source": 14,
    "AI Notes": 14,
    "AnkiOps Key": 14,
}
FIELD_DESCRIPTIONS = {
    "AI Notes": "Auto-generated by AI — do not edit",
    "AnkiOps Key": "Internal key for AnkiOps sync — do not edit",
}


def _action(action_str: str, **params) -> dict:
    return {"action": action_str, "params": params}


class AnkiAdapter:
    """Adapter for AnkiConnect HTTP API."""

    def __init__(self) -> None:
        self._media_dir: Path | None = None

    def get_version(self) -> int:
        """Get AnkiConnect version."""
        return invoke("version")

    def get_active_profile(self) -> str:
        """Get the currently active Anki profile name."""
        return invoke("getActiveProfile")

    def fetch_deck_names_and_ids(self) -> dict[str, int]:
        return invoke("deckNamesAndIds")

    def fetch_all_note_ids(self, required_types: list[str]) -> list[int]:
        if not required_types:
            return []
        query = " OR ".join(f"note:{m}" for m in required_types)
        return invoke("findNotes", query=query)

    def fetch_cards_info(self, card_ids: list[int]) -> dict[int, dict]:
        if not card_ids:
            return {}
        cards = invoke("cardsInfo", cards=card_ids)
        return {c["cardId"]: c for c in cards if c}

    def fetch_notes_info(self, note_ids: list[int]) -> dict[int, AnkiNote]:
        if not note_ids:
            return {}
        notes = invoke("notesInfo", notes=note_ids)
        res = {}
        for n in notes:
            if not n:
                continue
            fields = {name: data["value"] for name, data in n["fields"].items()}
            res[n["noteId"]] = AnkiNote(
                note_id=n["noteId"],
                note_type=n.get("modelName", ""),
                fields=fields,
                card_ids=n.get("cards", []),
            )
        return res

    def fetch_model_names(self) -> list[str]:
        return invoke("modelNames")

    def fetch_model_states(self, model_names: list[str]) -> dict[str, dict]:
        if not model_names:
            return {}
        read_actions = []
        for name in model_names:
            read_actions.append(_action("modelFieldNames", modelName=name))
            read_actions.append(_action("modelStyling", modelName=name))
            read_actions.append(_action("modelTemplates", modelName=name))
            read_actions.append(_action("modelFieldDescriptions", modelName=name))
            read_actions.append(_action("modelFieldFonts", modelName=name))

        read_results = invoke("multi", actions=read_actions)
        states = {}
        for i, name in enumerate(model_names):
            base = i * 5
            field_names = read_results[base]
            raw_desc = read_results[base + 3]
            descriptions = dict(zip(field_names, raw_desc))
            states[name] = {
                "fields": field_names,
                "styling": read_results[base + 1],
                "templates": read_results[base + 2],
                "descriptions": descriptions,
                "fonts": read_results[base + 4],
            }
        return states

    def create_models(self, models: list[NoteTypeConfig]) -> None:
        if not models:
            return
        actions = []
        for m in models:
            fields = [f.name for f in m.fields]
            actions.append(
                _action(
                    "createModel",
                    modelName=m.name,
                    inOrderFields=fields,
                    css=m.css,
                    isCloze=m.is_cloze,
                    cardTemplates=m.templates,
                )
            )
            # Apply descriptions / fonts
            for field_name, desc in FIELD_DESCRIPTIONS.items():
                if field_name in fields:
                    actions.append(
                        _action(
                            "modelFieldSetDescription",
                            modelName=m.name,
                            fieldName=field_name,
                            description=desc,
                        )
                    )
            for field_name, size in FIELD_FONT_SIZES.items():
                if field_name in fields:
                    actions.append(
                        _action(
                            "modelFieldSetFontSize",
                            modelName=m.name,
                            fieldName=field_name,
                            fontSize=size,
                        )
                    )

        results = invoke("multi", actions=actions)
        errors = [r for r in results if r is not None and isinstance(r, str)]
        if errors:
            raise AnkiConnectError(f"Failed to create models: {errors}")

    def update_models(
        self, models: list[NoteTypeConfig], states: dict[str, dict]
    ) -> None:
        if not models:
            return
        actions = []
        for m in models:
            state = states[m.name]
            expected_fields = [f.name for f in m.fields]
            current_fields = state["fields"]

            for f_name in expected_fields:
                if f_name not in current_fields:
                    actions.append(
                        _action("modelFieldAdd", modelName=m.name, fieldName=f_name)
                    )

            for f_name in current_fields:
                if f_name not in expected_fields:
                    actions.append(
                        _action("modelFieldRemove", modelName=m.name, fieldName=f_name)
                    )

            for i, f_name in enumerate(expected_fields):
                actions.append(
                    _action(
                        "modelFieldReposition",
                        modelName=m.name,
                        fieldName=f_name,
                        index=i,
                    )
                )

            actions.append(
                _action("updateModelStyling", model={"name": m.name, "css": m.css})
            )

            # Templates
            current_names = list(state["templates"].keys())
            for i, expected in enumerate(m.templates):
                if i < len(current_names) and current_names[i] != expected["Name"]:
                    actions.append(
                        _action(
                            "modelTemplateRename",
                            modelName=m.name,
                            oldTemplateName=current_names[i],
                            newTemplateName=expected["Name"],
                        )
                    )
                    current_names[i] = expected["Name"]

            templates_dict = {}
            for i, expected in enumerate(m.templates):
                if i < len(current_names):
                    templates_dict[current_names[i]] = {
                        "Front": expected["Front"],
                        "Back": expected["Back"],
                    }
                else:
                    actions.append(
                        _action(
                            "modelTemplateAdd",
                            modelName=m.name,
                            template=expected,
                        )
                    )

            if templates_dict:
                actions.append(
                    _action(
                        "updateModelTemplates",
                        model={"name": m.name, "templates": templates_dict},
                    )
                )

            # Descriptions and Fonts
            current_desc = state["descriptions"]
            current_fonts = state["fonts"]

            for f_name, desc in FIELD_DESCRIPTIONS.items():
                if current_desc.get(f_name) != desc and f_name in expected_fields:
                    actions.append(
                        _action(
                            "modelFieldSetDescription",
                            modelName=m.name,
                            fieldName=f_name,
                            description=desc,
                        )
                    )

            for f_name, size in FIELD_FONT_SIZES.items():
                if (
                    current_fonts.get(f_name, {}).get("size") != size
                    and f_name in expected_fields
                ):
                    actions.append(
                        _action(
                            "modelFieldSetFontSize",
                            modelName=m.name,
                            fieldName=f_name,
                            fontSize=size,
                        )
                    )

        if actions:
            results = invoke("multi", actions=actions)
            errors = [r for r in results if r is not None and isinstance(r, str)]
            if errors:
                raise AnkiConnectError(f"Failed to update models: {errors}")

    def apply_note_changes(
        self,
        deck_name: str,
        needs_create_deck: bool,
        creates: list[Change],
        updates: list[Change],
        deletes: list[Change],
        cards_to_move: list[int],
    ) -> tuple[list[int], list[str]]:
        actions = []
        tags = []
        errors = []
        created_ids = []

        if needs_create_deck:
            actions.append(_action("createDeck", deck=deck_name))
            tags.append("create_deck")

        if cards_to_move:
            actions.append(
                _action("changeDeck", cards=list(set(cards_to_move)), deck=deck_name)
            )
            tags.append("change_deck")

        for c in updates:
            note_id = c.entity_id
            fields = c.context.get("html_fields", {})
            actions.append(
                _action("updateNoteFields", note={"id": note_id, "fields": fields})
            )
            tags.append("update")

        if deletes:
            ids = [c.entity_id for c in deletes if c.entity_id]
            actions.append(_action("deleteNotes", notes=ids))
            tags.append("delete")

        for c in creates:
            note = c.context.get("note")
            fields = c.context.get("html_fields", {})
            note_type = note.note_type if note else ""
            if "note_key" in c.context:
                fields["AnkiOps Key"] = c.context["note_key"]

            actions.append(
                _action(
                    "addNote",
                    note={
                        "deckName": deck_name,
                        "modelName": note_type,
                        "fields": fields,
                        "options": {"allowDuplicate": False},
                    },
                )
            )
            tags.append("create")

        if actions:
            try:
                results = invoke("multi", actions=actions)
                update_idx = 0
                create_idx = 0
                for tag, res in zip(tags, results):
                    if tag == "update":
                        if res is not None:
                            errors.append(
                                f"Update failed ({updates[update_idx].entity_repr}): {res}"
                            )
                        update_idx += 1
                    elif tag == "create":
                        if isinstance(res, int):
                            created_ids.append(res)
                        else:
                            errors.append(
                                f"Create failed ({creates[create_idx].entity_repr}): {res}"
                            )
                        create_idx += 1
                    elif tag in ("change_deck", "delete"):
                        if res is not None:
                            errors.append(f"Failed {tag}: {res}")

            except AnkiConnectError as e:
                errors.append(str(e))

        return created_ids, errors

    def get_media_dir(self) -> Path:
        """Return Anki's collection.media directory, cached after first call."""
        cached = self._media_dir
        if cached is None:
            cached = Path(invoke("getMediaDirPath"))
            self._media_dir = cached
        return cached

    def push_media(self, local_path: Path, remote_filename: str) -> None:
        shutil.copy2(local_path, self.get_media_dir() / remote_filename)

    def pull_media(self, remote_filename: str, local_path: Path) -> bool:
        source = self.get_media_dir() / remote_filename
        if not source.exists():
            return False
        shutil.copy2(source, local_path)
        return True

    def find_notes_by_ankiops_key(self, key: str) -> list[int]:
        return invoke("findNotes", query=f'"AnkiOps Key:{key}"')
