"""AnkiConnect Adapter."""

import logging
import shutil
from pathlib import Path

from ankiops.anki_client import AnkiConnectError, invoke
from ankiops.models import (
    AnkiNote,
    Change,
    ChangeType,
    NoteTypeConfig,
)

logger = logging.getLogger(__name__)

# Editor-side field properties (set via AnkiConnect)
FIELD_FONT_SIZES = {
    "Source": 14,
    "AI Notes": 14,
    "AnkiOps Key": 14,
}
FIELD_DESCRIPTIONS = {
    "AI Notes": "Auto-generated by AI — do not edit",
    "AnkiOps Key": "Internal note_key for AnkiOps sync — do not edit",
}


def _action(action_str: str, **params) -> dict:
    return {"action": action_str, "params": params}


class AnkiAdapter:
    """Adapter for AnkiConnect HTTP API."""

    def __init__(self) -> None:
        self._media_dir: Path | None = None

    def get_version(self) -> int:
        """Get AnkiConnect version."""
        return invoke("version")

    def get_active_profile(self) -> str:
        """Get the currently active Anki profile name."""
        return invoke("getActiveProfile")

    def fetch_deck_names_and_ids(self) -> dict[str, int]:
        return invoke("deckNamesAndIds")

    def fetch_all_note_ids(self, required_types: list[str]) -> list[int]:
        if not required_types:
            return []
        query = " OR ".join(f"note:{model_name}" for model_name in required_types)
        return invoke("findNotes", query=query)

    def fetch_cards_info(self, card_ids: list[int]) -> dict[int, dict]:
        if not card_ids:
            return {}
        cards = invoke("cardsInfo", cards=card_ids)
        return {card["cardId"]: card for card in cards if card}

    def fetch_notes_info(self, note_ids: list[int]) -> dict[int, AnkiNote]:
        if not note_ids:
            return {}
        notes = invoke("notesInfo", notes=note_ids)
        notes_by_id = {}
        for note_data in notes:
            if not note_data:
                continue
            fields = {
                name: data["value"] for name, data in note_data["fields"].items()
            }
            notes_by_id[note_data["noteId"]] = AnkiNote(
                note_id=note_data["noteId"],
                note_type=note_data.get("modelName", ""),
                fields=fields,
                card_ids=note_data.get("cards", []),
            )
        return notes_by_id

    def fetch_model_names(self) -> list[str]:
        return invoke("modelNames")

    def fetch_model_states(self, model_names: list[str]) -> dict[str, dict]:
        if not model_names:
            return {}
        read_actions = []
        for name in model_names:
            read_actions.append(_action("modelFieldNames", modelName=name))
            read_actions.append(_action("modelStyling", modelName=name))
            read_actions.append(_action("modelTemplates", modelName=name))
            read_actions.append(_action("modelFieldDescriptions", modelName=name))
            read_actions.append(_action("modelFieldFonts", modelName=name))

        read_results = invoke("multi", actions=read_actions)
        states = {}
        for model_index, name in enumerate(model_names):
            base = model_index * 5
            field_names = read_results[base]
            raw_desc = read_results[base + 3]
            descriptions = dict(zip(field_names, raw_desc))
            states[name] = {
                "fields": field_names,
                "styling": read_results[base + 1],
                "templates": read_results[base + 2],
                "descriptions": descriptions,
                "fonts": read_results[base + 4],
            }
        return states

    def create_models(self, models: list[NoteTypeConfig]) -> None:
        if not models:
            return
        actions = []
        for model_config in models:
            fields = [field.name for field in model_config.fields]
            actions.append(
                _action(
                    "createModel",
                    modelName=model_config.name,
                    inOrderFields=fields,
                    css=model_config.css,
                    isCloze=model_config.is_cloze,
                    cardTemplates=model_config.templates,
                )
            )
            # Apply descriptions / fonts
            for field_name, desc in FIELD_DESCRIPTIONS.items():
                if field_name in fields:
                    actions.append(
                        _action(
                            "modelFieldSetDescription",
                            modelName=model_config.name,
                            fieldName=field_name,
                            description=desc,
                        )
                    )
            for field_name, size in FIELD_FONT_SIZES.items():
                if field_name in fields:
                    actions.append(
                        _action(
                            "modelFieldSetFontSize",
                            modelName=model_config.name,
                            fieldName=field_name,
                            fontSize=size,
                        )
                    )

        results = invoke("multi", actions=actions)
        errors = [
            result for result in results if result is not None and isinstance(result, str)
        ]
        if errors:
            raise AnkiConnectError(f"Failed to create models: {errors}")

    def update_models(
        self, models: list[NoteTypeConfig], states: dict[str, dict]
    ) -> None:
        if not models:
            return
        actions = []
        for model_config in models:
            state = states[model_config.name]
            expected_fields = [field.name for field in model_config.fields]
            current_fields = state["fields"]

            for field_name in expected_fields:
                if field_name not in current_fields:
                    actions.append(
                        _action(
                            "modelFieldAdd",
                            modelName=model_config.name,
                            fieldName=field_name,
                        )
                    )

            for field_name in current_fields:
                if field_name not in expected_fields:
                    actions.append(
                        _action(
                            "modelFieldRemove",
                            modelName=model_config.name,
                            fieldName=field_name,
                        )
                    )

            for field_index, field_name in enumerate(expected_fields):
                actions.append(
                    _action(
                        "modelFieldReposition",
                        modelName=model_config.name,
                        fieldName=field_name,
                        index=field_index,
                    )
                )

            actions.append(
                _action(
                    "updateModelStyling",
                    model={"name": model_config.name, "css": model_config.css},
                )
            )

            # Templates
            current_names = list(state["templates"].keys())
            for template_index, expected in enumerate(model_config.templates):
                if (
                    template_index < len(current_names)
                    and current_names[template_index] != expected["Name"]
                ):
                    actions.append(
                        _action(
                            "modelTemplateRename",
                            modelName=model_config.name,
                            oldTemplateName=current_names[template_index],
                            newTemplateName=expected["Name"],
                        )
                    )
                    current_names[template_index] = expected["Name"]

            templates_dict = {}
            for template_index, expected in enumerate(model_config.templates):
                if template_index < len(current_names):
                    templates_dict[current_names[template_index]] = {
                        "Front": expected["Front"],
                        "Back": expected["Back"],
                    }
                else:
                    actions.append(
                        _action(
                            "modelTemplateAdd",
                            modelName=model_config.name,
                            template=expected,
                        )
                    )

            if templates_dict:
                actions.append(
                    _action(
                        "updateModelTemplates",
                        model={"name": model_config.name, "templates": templates_dict},
                    )
                )

            # Descriptions and Fonts
            current_desc = state["descriptions"]
            current_fonts = state["fonts"]

            for field_name, desc in FIELD_DESCRIPTIONS.items():
                if current_desc.get(field_name) != desc and field_name in expected_fields:
                    actions.append(
                        _action(
                            "modelFieldSetDescription",
                            modelName=model_config.name,
                            fieldName=field_name,
                            description=desc,
                        )
                    )

            for field_name, size in FIELD_FONT_SIZES.items():
                if (
                    current_fonts.get(field_name, {}).get("size") != size
                    and field_name in expected_fields
                ):
                    actions.append(
                        _action(
                            "modelFieldSetFontSize",
                            modelName=model_config.name,
                            fieldName=field_name,
                            fontSize=size,
                        )
                    )

        if actions:
            results = invoke("multi", actions=actions)
            errors = [
                result
                for result in results
                if result is not None and isinstance(result, str)
            ]
            if errors:
                raise AnkiConnectError(f"Failed to update models: {errors}")

    def apply_note_changes(
        self,
        deck_name: str,
        needs_create_deck: bool,
        creates: list[Change],
        updates: list[Change],
        deletes: list[Change],
        cards_to_move: list[int],
    ) -> tuple[list[int], list[str]]:
        actions = []
        tags = []
        errors = []
        created_ids = []
        create_deck_failed = False

        if needs_create_deck:
            actions.append(_action("createDeck", deck=deck_name))
            tags.append("create_deck")

        if cards_to_move:
            actions.append(
                _action("changeDeck", cards=sorted(set(cards_to_move)), deck=deck_name)
            )
            tags.append("change_deck")

        for update_change in updates:
            note_id = update_change.entity_id
            fields = update_change.context.get("html_fields", {})
            actions.append(
                _action("updateNoteFields", note={"id": note_id, "fields": fields})
            )
            tags.append("update")

        if deletes:
            note_ids = [
                delete_change.entity_id
                for delete_change in deletes
                if delete_change.entity_id
            ]
            actions.append(_action("deleteNotes", notes=note_ids))
            tags.append("delete")

        if actions:
            try:
                results = invoke("multi", actions=actions)
                update_idx = 0
                for tag, action_result in zip(tags, results):
                    if tag == "update":
                        if isinstance(action_result, str):
                            errors.append(
                                "Update failed "
                                f"({updates[update_idx].entity_repr}): {action_result}"
                            )
                        update_idx += 1
                    elif tag == "create_deck":
                        if isinstance(action_result, str):
                            create_deck_failed = True
                            errors.append(f"Failed create_deck: {action_result}")
                    elif tag in ("change_deck", "delete"):
                        if isinstance(action_result, str):
                            errors.append(f"Failed {tag}: {action_result}")

            except AnkiConnectError as error:
                errors.append(str(error))

        if creates:
            if create_deck_failed:
                for create_change in creates:
                    errors.append(
                        f"Create failed ({create_change.entity_repr}): deck create failed"
                    )
            else:
                create_ids, create_errors = self._create_notes_bulk(deck_name, creates)
                created_ids.extend(create_ids)
                errors.extend(create_errors)

        return created_ids, errors

    def _build_create_note_payload(self, deck_name: str, change: Change) -> dict:
        note = change.context.get("note")
        fields = dict(change.context.get("html_fields", {}))
        note_type = note.note_type if note else ""
        if "note_key" in change.context:
            fields["AnkiOps Key"] = change.context["note_key"]
        return {
            "deckName": deck_name,
            "modelName": note_type,
            "fields": fields,
            "options": {"allowDuplicate": False},
        }

    def _collect_create_results(
        self, creates: list[Change], results: object
    ) -> tuple[list[int], list[str]]:
        created_ids: list[int] = []
        errors: list[str] = []

        if not isinstance(results, list):
            return [], [f"Create failed: unexpected addNotes result: {results!r}"]

        normalized = list(results)
        if len(normalized) < len(creates):
            normalized.extend([None] * (len(creates) - len(normalized)))

        for create_change, create_result in zip(creates, normalized):
            if isinstance(create_result, int):
                created_ids.append(create_result)
            else:
                errors.append(
                    f"Create failed ({create_change.entity_repr}): {create_result}"
                )

        return created_ids, errors

    def _create_notes_bulk(
        self, deck_name: str, creates: list[Change]
    ) -> tuple[list[int], list[str]]:
        notes = [
            self._build_create_note_payload(deck_name, create_change)
            for create_change in creates
        ]
        try:
            results = invoke("addNotes", notes=notes)
            return self._collect_create_results(creates, results)
        except AnkiConnectError as error:
            return [], [str(error)]

    def get_media_dir(self) -> Path:
        """Return Anki's collection.media directory, cached after first call."""
        cached = self._media_dir
        if cached is None:
            cached = Path(invoke("getMediaDirPath"))
            self._media_dir = cached
        return cached

    def push_media(self, local_path: Path, remote_filename: str) -> None:
        shutil.copyfile(local_path, self.get_media_dir() / remote_filename)

    def pull_media(self, remote_filename: str, local_path: Path) -> bool:
        source = self.get_media_dir() / remote_filename
        if not source.exists():
            return False
        shutil.copyfile(source, local_path)
        return True

    def find_notes_by_ankiops_note_key(self, note_key: str) -> list[int]:
        return invoke("findNotes", query=f'"AnkiOps Key:{note_key}"')
