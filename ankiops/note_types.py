"""Ensure all AnkiOps note types exist in Anki and are up to date with our templates."""

import logging
from importlib import resources

from ankiops.anki_client import invoke
from ankiops.config import NOTE_TYPES

# Editor-side field properties (set via AnkiConnect, not card templates)
FIELD_DESCRIPTIONS: dict[str, str] = {
    "AI Notes": "Auto-generated by AI — do not edit",
}
FIELD_FONT_SIZES: dict[str, int] = {
    "Source": 14,
    "AI Notes": 14,
}

logger = logging.getLogger(__name__)


def _load_template(filename: str) -> str:
    """Read a card template file from the card_templates directory."""
    return (
        resources.files("ankiops.card_templates")
        .joinpath(filename)
        .read_text(encoding="utf-8")
    )


def _get_card_templates(model_name: str) -> list[dict[str, str]]:
    """Get card templates for a model.

    Returns a list of card template dicts with Name, Front, and Back keys.
    Most models have one card, but AnkiOpsReversed has two (forward and reverse).
    """
    front = _load_template(f"{model_name}Front.template.anki")
    back = _load_template(f"{model_name}Back.template.anki")

    templates = [{"Name": "Card 1", "Front": front, "Back": back}]
    if model_name == "AnkiOpsCloze":
        templates[0]["Name"] = "Cloze"

    # AnkiOpsReversed has a second card for the reverse direction
    if model_name == "AnkiOpsReversed":
        front2 = _load_template(f"{model_name}Front2.template.anki")
        back2 = _load_template(f"{model_name}Back2.template.anki")
        templates.append({"Name": "Card 2", "Front": front2, "Back": back2})

    return templates


def _set_field_properties(model_name: str) -> None:
    """Set editor-side field properties (descriptions, font sizes)."""
    for field_name, description in FIELD_DESCRIPTIONS.items():
        invoke(
            "modelFieldSetDescription",
            modelName=model_name,
            fieldName=field_name,
            description=description,
        )
    for field_name, size in FIELD_FONT_SIZES.items():
        invoke(
            "modelFieldSetFontSize",
            modelName=model_name,
            fieldName=field_name,
            fontSize=size,
        )


def _create_model(model_name: str, is_cloze: bool) -> None:
    """Create a note type in Anki from the template files."""
    cfg = NOTE_TYPES[model_name]
    fields = [field_name for field_name, _, _ in cfg["field_mappings"]]

    css = _load_template("Styling.css")
    card_templates = _get_card_templates(model_name)

    invoke(
        "createModel",
        modelName=model_name,
        inOrderFields=fields,
        css=css,
        isCloze=is_cloze,
        cardTemplates=card_templates,
    )
    _set_field_properties(model_name)
    logger.info(f"Created note type '{model_name}' in Anki")


def _is_model_up_to_date(model_name: str) -> bool:
    """Check if a model's fields, templates, and styling match our config."""
    cfg = NOTE_TYPES[model_name]
    expected_fields = [field_name for field_name, _, _ in cfg["field_mappings"]]
    css = _load_template("Styling.css")
    expected_templates = _get_card_templates(model_name)

    # Get current model info from Anki
    current_fields = invoke("modelFieldNames", modelName=model_name)
    current_styling = invoke("modelStyling", modelName=model_name)
    current_templates = invoke("modelTemplates", modelName=model_name)

    # Compare fields
    if current_fields != expected_fields:
        return False

    # Compare styling
    if current_styling.get("css", "").strip() != css.strip():
        return False

    # Compare card templates by position
    current_names = list(current_templates.keys())
    current_template_list = list(current_templates.values())
    if len(current_template_list) != len(expected_templates):
        return False

    for i, (current, expected) in enumerate(
        zip(current_template_list, expected_templates)
    ):
        if current_names[i] != expected["Name"]:
            return False
        if current.get("Front", "").strip() != expected["Front"].strip():
            return False
        if current.get("Back", "").strip() != expected["Back"].strip():
            return False

    return True


def _update_model(model_name: str) -> None:
    """Update an existing note type's fields, card templates, and styling."""
    cfg = NOTE_TYPES[model_name]
    expected_fields = [field_name for field_name, _, _ in cfg["field_mappings"]]
    css = _load_template("Styling.css")
    expected_templates = _get_card_templates(model_name)

    # Update fields — add missing, remove stale, reposition to match config order
    current_fields = invoke("modelFieldNames", modelName=model_name)

    for field_name in expected_fields:
        if field_name not in current_fields:
            invoke("modelFieldAdd", modelName=model_name, fieldName=field_name)

    for field_name in current_fields:
        if field_name not in expected_fields:
            invoke("modelFieldRemove", modelName=model_name, fieldName=field_name)

    for i, field_name in enumerate(expected_fields):
        invoke(
            "modelFieldReposition",
            modelName=model_name,
            fieldName=field_name,
            index=i,
        )

    # Update styling
    invoke("updateModelStyling", model={"name": model_name, "css": css})

    # Update card templates by position.
    # Rename mismatched names, add genuinely new templates (e.g. Card 2 for reversed).
    current_templates = invoke("modelTemplates", modelName=model_name)
    current_names = list(current_templates.keys())

    # Rename templates first so updateModelTemplates uses the correct names
    for i, expected in enumerate(expected_templates):
        if i < len(current_names) and current_names[i] != expected["Name"]:
            invoke(
                "modelTemplateRename",
                modelName=model_name,
                oldTemplateName=current_names[i],
                newTemplateName=expected["Name"],
            )
            current_names[i] = expected["Name"]

    templates_dict = {}
    for i, expected in enumerate(expected_templates):
        if i < len(current_names):
            templates_dict[current_names[i]] = {
                "Front": expected["Front"],
                "Back": expected["Back"],
            }
        else:
            invoke(
                "modelTemplateAdd",
                modelName=model_name,
                template={
                    "Name": expected["Name"],
                    "Front": expected["Front"],
                    "Back": expected["Back"],
                },
            )

    if templates_dict:
        invoke(
            "updateModelTemplates",
            model={"name": model_name, "templates": templates_dict},
        )

    _set_field_properties(model_name)
    logger.info(f"Updated note type '{model_name}' in Anki")


def ensure_note_types() -> None:
    """Ensure all required note types exist in Anki and are up to date."""
    existing = set(invoke("modelNames"))

    for model_name in NOTE_TYPES.keys():
        if model_name not in existing:
            _create_model(model_name, is_cloze=("cloze" in model_name.lower()))
        elif not _is_model_up_to_date(model_name):
            _update_model(model_name)


if __name__ == "__main__":
    ensure_note_types()
    print(_is_model_up_to_date("AnkiOpsQA"))
