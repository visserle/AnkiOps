"""Ensure all AnkiOps note types exist in Anki and are up to date with our templates.

Architecture:
  Read phase  – one multi call fetches all model state from Anki
  Diff phase  – compare local config/templates against Anki state
  Write phase – one multi call applies all creates/updates
"""

import logging
from importlib import resources

from ankiops.anki_client import invoke
from ankiops.config import NOTE_CONFIG

# Editor-side field properties (set via AnkiConnect, not card templates)
FIELD_DESCRIPTIONS: dict[str, str] = {
    "AI Notes": "Auto-generated by AI — do not edit",
}
FIELD_FONT_SIZES: dict[str, int] = {
    "Source": 14,
    "AI Notes": 14,
}

logger = logging.getLogger(__name__)


# ---------------------------------------------------------------------------
# Helpers (pure data, no API calls)
# ---------------------------------------------------------------------------


def _action(action: str, **params) -> dict:
    """Build an AnkiConnect action dict for use in a multi call."""
    return {"action": action, "params": params}


def _load_template(filename: str) -> str:
    """Read a card template file from the card_templates directory."""
    return (
        resources.files("ankiops.card_templates")
        .joinpath(filename)
        .read_text(encoding="utf-8")
    )


def _get_card_templates(model_name: str) -> list[dict[str, str]]:
    """Get card templates for a model.

    Returns a list of card template dicts with Name, Front, and Back keys.
    Most models have one card, but AnkiOpsReversed has two (forward and reverse).
    """
    front = _load_template(f"{model_name}Front.template.anki")
    back = _load_template(f"{model_name}Back.template.anki")

    templates = [{"Name": "Card 1", "Front": front, "Back": back}]
    if model_name == "AnkiOpsCloze":
        templates[0]["Name"] = "Cloze"

    # AnkiOpsReversed has a second card for the reverse direction
    if model_name == "AnkiOpsReversed":
        front2 = _load_template(f"{model_name}Front2.template.anki")
        back2 = _load_template(f"{model_name}Back2.template.anki")
        templates.append({"Name": "Card 2", "Front": front2, "Back": back2})

    return templates


# ---------------------------------------------------------------------------
# Action-dict builders (return lists of action dicts, never call invoke)
# ---------------------------------------------------------------------------


def _field_property_actions(
    model_name: str, model_state: dict | None = None
) -> list[dict]:
    """Return action dicts for editor-side field properties (descriptions, font sizes).

    When model_state is provided (update path), only emits actions for values
    that differ from the current Anki state.  When None (create path), emits
    all actions unconditionally.
    """
    # Create path: emit all actions unconditionally
    if model_state is None:
        actions: list[dict] = []
        for field_name, description in FIELD_DESCRIPTIONS.items():
            actions.append(
                _action(
                    "modelFieldSetDescription",
                    modelName=model_name,
                    fieldName=field_name,
                    description=description,
                )
            )
        for field_name, size in FIELD_FONT_SIZES.items():
            actions.append(
                _action(
                    "modelFieldSetFontSize",
                    modelName=model_name,
                    fieldName=field_name,
                    fontSize=size,
                )
            )
        return actions

    # Update path: only emit actions for values that differ
    actions = []
    current_descriptions = model_state["descriptions"]
    current_fonts = model_state["fonts"]

    for field_name, description in FIELD_DESCRIPTIONS.items():
        if current_descriptions.get(field_name) != description:
            actions.append(
                _action(
                    "modelFieldSetDescription",
                    modelName=model_name,
                    fieldName=field_name,
                    description=description,
                )
            )
    for field_name, size in FIELD_FONT_SIZES.items():
        if current_fonts.get(field_name, {}).get("size") != size:
            actions.append(
                _action(
                    "modelFieldSetFontSize",
                    modelName=model_name,
                    fieldName=field_name,
                    fontSize=size,
                )
            )
    return actions


def _create_model_actions(model_name: str, is_cloze: bool) -> list[dict]:
    """Return action dicts to create a note type from scratch."""
    note_config = NOTE_CONFIG[model_name]
    fields = [field_name for field_name, _ in note_config]

    css = _load_template("Styling.css")
    card_templates = _get_card_templates(model_name)

    actions: list[dict] = [
        _action(
            "createModel",
            modelName=model_name,
            inOrderFields=fields,
            css=css,
            isCloze=is_cloze,
            cardTemplates=card_templates,
        )
    ]
    actions.extend(_field_property_actions(model_name))
    return actions


def _is_model_up_to_date(model_name: str, model_state: dict) -> bool:
    """Check if a model's fields, templates, styling, and field properties match.

    Args:
        model_name: The note type name.
        model_state: Pre-fetched dict with keys 'fields', 'styling', 'templates',
                     'descriptions', 'fonts'.
    """
    note_config = NOTE_CONFIG[model_name]
    expected_fields = [field_name for field_name, _ in note_config]
    css = _load_template("Styling.css")
    expected_templates = _get_card_templates(model_name)

    current_fields = model_state["fields"]
    current_styling = model_state["styling"]
    current_templates = model_state["templates"]

    # Compare fields
    if current_fields != expected_fields:
        return False

    # Compare styling
    if current_styling.get("css", "").strip() != css.strip():
        return False

    # Compare card templates by position
    current_names = list(current_templates.keys())
    current_template_list = list(current_templates.values())
    if len(current_template_list) != len(expected_templates):
        return False

    for i, (current, expected) in enumerate(
        zip(current_template_list, expected_templates)
    ):
        if current_names[i] != expected["Name"]:
            return False
        if current.get("Front", "").strip() != expected["Front"].strip():
            return False
        if current.get("Back", "").strip() != expected["Back"].strip():
            return False

    # Compare field descriptions
    current_descriptions = model_state["descriptions"]
    for field_name, description in FIELD_DESCRIPTIONS.items():
        if current_descriptions.get(field_name) != description:
            return False

    # Compare field font sizes
    current_fonts = model_state["fonts"]
    for field_name, size in FIELD_FONT_SIZES.items():
        if current_fonts.get(field_name, {}).get("size") != size:
            return False

    return True


def _update_model_actions(model_name: str, model_state: dict) -> list[dict]:
    """Return action dicts to update an existing note type.

    Args:
        model_name: The note type name.
        model_state: Pre-fetched dict with keys 'fields', 'styling', 'templates',
                     'descriptions', 'fonts'.
    """
    note_config = NOTE_CONFIG[model_name]
    expected_fields = [field_name for field_name, _ in note_config]
    css = _load_template("Styling.css")
    expected_templates = _get_card_templates(model_name)

    actions: list[dict] = []
    current_fields = model_state["fields"]

    # Update fields — add missing, remove stale, reposition to match config order
    for field_name in expected_fields:
        if field_name not in current_fields:
            actions.append(
                _action("modelFieldAdd", modelName=model_name, fieldName=field_name)
            )

    for field_name in current_fields:
        if field_name not in expected_fields:
            actions.append(
                _action("modelFieldRemove", modelName=model_name, fieldName=field_name)
            )

    for i, field_name in enumerate(expected_fields):
        actions.append(
            _action(
                "modelFieldReposition",
                modelName=model_name,
                fieldName=field_name,
                index=i,
            )
        )

    # Update styling
    actions.append(
        _action("updateModelStyling", model={"name": model_name, "css": css})
    )

    # Update card templates by position.
    # Rename mismatched names, add genuinely new templates (e.g. Card 2 for reversed).
    current_templates = model_state["templates"]
    current_names = list(current_templates.keys())

    # Rename templates first so updateModelTemplates uses the correct names
    for i, expected in enumerate(expected_templates):
        if i < len(current_names) and current_names[i] != expected["Name"]:
            actions.append(
                _action(
                    "modelTemplateRename",
                    modelName=model_name,
                    oldTemplateName=current_names[i],
                    newTemplateName=expected["Name"],
                )
            )
            current_names[i] = expected["Name"]

    templates_dict = {}
    for i, expected in enumerate(expected_templates):
        if i < len(current_names):
            templates_dict[current_names[i]] = {
                "Front": expected["Front"],
                "Back": expected["Back"],
            }
        else:
            actions.append(
                _action(
                    "modelTemplateAdd",
                    modelName=model_name,
                    template={
                        "Name": expected["Name"],
                        "Front": expected["Front"],
                        "Back": expected["Back"],
                    },
                )
            )

    if templates_dict:
        actions.append(
            _action(
                "updateModelTemplates",
                model={"name": model_name, "templates": templates_dict},
            )
        )

    actions.extend(_field_property_actions(model_name, model_state))
    return actions


# ---------------------------------------------------------------------------
# Public API
# ---------------------------------------------------------------------------


def ensure_note_types() -> None:
    """Ensure all required note types exist in Anki and are up to date.

    Phases:
      1. Fetch existing model names (1 call)
      2. Batch-read state for all existing models (1 multi call)
      3. Diff local config vs Anki state, build action dicts
      4. Batch-write all creates/updates (1 multi call)
    """
    existing = set(invoke("modelNames"))
    models_to_check = [m for m in NOTE_CONFIG if m in existing]
    models_to_create = [m for m in NOTE_CONFIG if m not in existing]

    # ---- Phase 2: Batch-read all model state ----
    model_states: dict[str, dict] = {}

    if models_to_check:
        read_actions: list[dict] = []
        for model_name in models_to_check:
            read_actions.append(_action("modelFieldNames", modelName=model_name))
            read_actions.append(_action("modelStyling", modelName=model_name))
            read_actions.append(_action("modelTemplates", modelName=model_name))
            read_actions.append(_action("modelFieldDescriptions", modelName=model_name))
            read_actions.append(_action("modelFieldFonts", modelName=model_name))

        read_results = invoke("multi", actions=read_actions)

        for i, model_name in enumerate(models_to_check):
            base = i * 5
            # modelFieldDescriptions returns a list (positional), zip with field names
            field_names = read_results[base]
            raw_descriptions = read_results[base + 3]
            descriptions = dict(zip(field_names, raw_descriptions))

            model_states[model_name] = {
                "fields": field_names,
                "styling": read_results[base + 1],
                "templates": read_results[base + 2],
                "descriptions": descriptions,
                "fonts": read_results[base + 4],
            }

    # ---- Phase 3: Diff + build action dicts ----
    write_actions: list[dict] = []

    for model_name in models_to_create:
        write_actions.extend(
            _create_model_actions(model_name, is_cloze="cloze" in model_name.lower())
        )
        logger.info(f"Created note type '{model_name}' in Anki")

    for model_name in models_to_check:
        if not _is_model_up_to_date(model_name, model_states[model_name]):
            write_actions.extend(
                _update_model_actions(model_name, model_states[model_name])
            )
            logger.info(f"Updated note type '{model_name}' in Anki")

    # ---- Phase 4: Batch-write all changes ----
    if write_actions:
        results = invoke("multi", actions=write_actions)
        errors = [r for r in results if r is not None and isinstance(r, str)]
        if errors:
            raise Exception(f"Note type sync errors: {errors}")


if __name__ == "__main__":
    ensure_note_types()
