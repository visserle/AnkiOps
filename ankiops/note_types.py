"""Ensure all AnkiOps note types exist in Anki and are up to date with our templates.

Architecture:
  Read phase  – one multi call fetches all model state from Anki
  Diff phase  – compare local config/templates against Anki state
  Write phase – one multi call applies all creates/updates
"""

import logging
from pathlib import Path

from ankiops.anki_client import AnkiConnectError, invoke
from ankiops.note_type_config import NoteTypeConfig, registry

# Editor-side field properties (set via AnkiConnect, not card templates)
FIELD_FONT_SIZES: dict[str, int] = {
    "Source": 14,
    "AI Notes": 14,
    "AnkiOps Key": 14,
}
FIELD_DESCRIPTIONS: dict[str, str] = {
    "AI Notes": "Auto-generated by AI — do not edit",
    "AnkiOps Key": "Internal key for AnkiOps sync — do not edit",
}

logger = logging.getLogger(__name__)


def _action(action: str, **params) -> dict:
    """Build an AnkiConnect action dict for use in a multi call."""
    return {"action": action, "params": params}


def _load_template_content(filename: str, package_dir: Path) -> str | None:
    """Read a card template file from a package directory."""
    custom_path = package_dir / filename
    if custom_path.exists():
        return custom_path.read_text(encoding="utf-8")
    return None


def _get_card_templates(config: NoteTypeConfig) -> list[dict[str, str]]:
    """Get card templates for a model configuration.

    Returns a list of card template dicts with Name, Front, and Back keys.
    Dynamically scans for FrontN/BackN templates to support arbitrary card counts.
    """
    model_name = config.name
    pkg_dir = config.package_dir
    if not pkg_dir:
        raise ValueError(f"Note type {model_name} has no package directory.")

    first_card_name = "Cloze" if config.is_cloze else "Card 1"

    # CASE 1: Explicit mapping in YAML
    if config.card_templates:
        templates = []
        for t in config.card_templates:
            f_content = _load_template_content(t["front"], pkg_dir)
            b_content = _load_template_content(t["back"], pkg_dir)

            if f_content is None or b_content is None:
                raise FileNotFoundError(
                    f"Template file '{t['front']}' or '{t['back']}' not found in {pkg_dir}"
                )

            # Narrow to str for type checker
            f_val: str = f_content if f_content is not None else ""
            b_val: str = b_content if b_content is not None else ""

            # Explicitly create dict to satisfy type checker narrowing
            card_dict: dict[str, str] = {
                "Name": str(t.get("name", "Card")),
                "Front": f_val,
                "Back": b_val,
            }
            templates.append(card_dict)
        return templates

    # CASE 2: Global naming convention (Front.template.anki, etc)
    templates = []

    # Card 1 (Base)
    front = _load_template_content("Front.template.anki", pkg_dir)
    back = _load_template_content("Back.template.anki", pkg_dir)

    if front is None or back is None:
        raise FileNotFoundError(f"Missing base templates (Front/Back) for {model_name}")

    first_card_name = "Cloze" if config.is_cloze else "Card 1"
    templates.append({"Name": first_card_name, "Front": str(front), "Back": str(back)})

    # Card 2+ (Dynamic)
    i = 2
    while True:
        front_n = _load_template_content(f"Front{i}.template.anki", pkg_dir)
        back_n = _load_template_content(f"Back{i}.template.anki", pkg_dir)

        if front_n is not None and back_n is not None:
            templates.append(
                {"Name": f"Card {i}", "Front": str(front_n), "Back": str(back_n)}
            )
            i += 1
        else:
            break

    return templates


def _field_property_actions(
    model_name: str, model_state: dict | None = None
) -> list[dict]:
    """Return action dicts for editor-side field properties (descriptions, font sizes).

    When model_state is provided (update path), only emits actions for values
    that differ from the current Anki state.  When None (create path), emits
    all actions unconditionally.
    """
    # Create path: emit all actions unconditionally
    if model_state is None:
        actions: list[dict] = []
        for field_name, description in FIELD_DESCRIPTIONS.items():
            actions.append(
                _action(
                    "modelFieldSetDescription",
                    modelName=model_name,
                    fieldName=field_name,
                    description=description,
                )
            )
        for field_name, size in FIELD_FONT_SIZES.items():
            actions.append(
                _action(
                    "modelFieldSetFontSize",
                    modelName=model_name,
                    fieldName=field_name,
                    fontSize=size,
                )
            )
        return actions

    # Update path: only emit actions for values that differ
    actions = []
    current_descriptions = model_state["descriptions"]
    current_fonts = model_state["fonts"]

    for field_name, description in FIELD_DESCRIPTIONS.items():
        if current_descriptions.get(field_name) != description:
            actions.append(
                _action(
                    "modelFieldSetDescription",
                    modelName=model_name,
                    fieldName=field_name,
                    description=description,
                )
            )
    for field_name, size in FIELD_FONT_SIZES.items():
        if current_fonts.get(field_name, {}).get("size") != size:
            actions.append(
                _action(
                    "modelFieldSetFontSize",
                    modelName=model_name,
                    fieldName=field_name,
                    fontSize=size,
                )
            )
    return actions


def _create_model_actions(model_name: str, is_cloze: bool) -> list[dict]:
    """Return action dicts to create a note type from scratch."""
    model_config = registry.get(model_name)
    fields = [f.name for f in model_config.fields]

    css = model_config.css

    card_templates = _get_card_templates(registry.get(model_name))

    actions: list[dict] = [
        _action(
            "createModel",
            modelName=model_name,
            inOrderFields=fields,
            css=css,
            isCloze=is_cloze,
            cardTemplates=card_templates,
        )
    ]
    actions.extend(_field_property_actions(model_name))
    return actions


def _is_model_up_to_date(model_name: str, model_state: dict) -> bool:
    """Check if a model's fields, templates, styling, and field properties match.

    Args:
        model_name: The note type name.
        model_state: Pre-fetched dict with keys 'fields', 'styling', 'templates',
                     'descriptions', 'fonts'.
    """
    model_config = registry.get(model_name)
    expected_fields = [f.name for f in model_config.fields]

    css = model_config.css

    expected_templates = _get_card_templates(model_config)

    current_fields = model_state["fields"]
    current_styling = model_state["styling"]
    current_templates = model_state["templates"]

    # Compare fields
    if current_fields != expected_fields:
        return False

    # Compare styling
    if current_styling.get("css", "").strip() != css.strip():
        return False

    # Compare card templates by position
    current_names = list(current_templates.keys())
    current_template_list = list(current_templates.values())
    if len(current_template_list) != len(expected_templates):
        return False

    for i, (current, expected) in enumerate(
        zip(current_template_list, expected_templates)
    ):
        if current_names[i] != expected["Name"]:
            return False
        if current.get("Front", "").strip() != expected["Front"].strip():
            return False
        if current.get("Back", "").strip() != expected["Back"].strip():
            return False

    # Compare field descriptions
    current_descriptions = model_state["descriptions"]
    for field_name, description in FIELD_DESCRIPTIONS.items():
        if current_descriptions.get(field_name) != description:
            return False

    # Compare field font sizes
    current_fonts = model_state["fonts"]
    for field_name, size in FIELD_FONT_SIZES.items():
        if current_fonts.get(field_name, {}).get("size") != size:
            return False

    return True


def _update_model_actions(model_name: str, model_state: dict) -> list[dict]:
    """Return action dicts to update an existing note type.

    Args:
        model_name: The note type name.
        model_state: Pre-fetched dict with keys 'fields', 'styling', 'templates',
                     'descriptions', 'fonts'.
    """
    model_config = registry.get(model_name)
    expected_fields = [f.name for f in model_config.fields]

    css = model_config.css

    expected_templates = _get_card_templates(model_config)

    actions: list[dict] = []
    current_fields = model_state["fields"]

    # Update fields — add missing, remove stale, reposition to match config order
    for field_name in expected_fields:
        if field_name not in current_fields:
            actions.append(
                _action("modelFieldAdd", modelName=model_name, fieldName=field_name)
            )

    for field_name in current_fields:
        if field_name not in expected_fields:
            actions.append(
                _action("modelFieldRemove", modelName=model_name, fieldName=field_name)
            )

    for i, field_name in enumerate(expected_fields):
        actions.append(
            _action(
                "modelFieldReposition",
                modelName=model_name,
                fieldName=field_name,
                index=i,
            )
        )

    # Update styling
    actions.append(
        _action("updateModelStyling", model={"name": model_name, "css": css})
    )

    # Update card templates by position.
    # Rename mismatched names, add genuinely new templates (e.g. Card 2 for reversed).
    current_templates = model_state["templates"]
    current_names = list(current_templates.keys())

    # Rename templates first so updateModelTemplates uses the correct names
    for i, expected in enumerate(expected_templates):
        if i < len(current_names) and current_names[i] != expected["Name"]:
            actions.append(
                _action(
                    "modelTemplateRename",
                    modelName=model_name,
                    oldTemplateName=current_names[i],
                    newTemplateName=expected["Name"],
                )
            )
            current_names[i] = expected["Name"]

    templates_dict = {}
    for i, expected in enumerate(expected_templates):
        if i < len(current_names):
            templates_dict[current_names[i]] = {
                "Front": expected["Front"],
                "Back": expected["Back"],
            }
        else:
            actions.append(
                _action(
                    "modelTemplateAdd",
                    modelName=model_name,
                    template={
                        "Name": expected["Name"],
                        "Front": expected["Front"],
                        "Back": expected["Back"],
                    },
                )
            )

    if templates_dict:
        actions.append(
            _action(
                "updateModelTemplates",
                model={"name": model_name, "templates": templates_dict},
            )
        )

    actions.extend(_field_property_actions(model_name, model_state))
    return actions


def ensure_note_types() -> None:
    """Ensure all required note types exist in Anki and are up to date.

    Phases:
      1. Fetch existing model names (1 call)
      2. Batch-read state for all existing models (1 multi call)
      3. Diff local config vs Anki state, build action dicts
      4. Batch-write all creates/updates (1 multi call)
    """
    registry.load()
    existing = set(invoke("modelNames"))

    # We check all supported note types (built-in + custom)
    required_types = registry.supported_note_types

    models_to_check = [m for m in required_types if m in existing]
    models_to_create = [m for m in required_types if m not in existing]

    # ---- Phase 2: Batch-read all model state ----
    model_states: dict[str, dict] = {}

    if models_to_check:
        read_actions: list[dict] = []
        for model_name in models_to_check:
            read_actions.append(_action("modelFieldNames", modelName=model_name))
            read_actions.append(_action("modelStyling", modelName=model_name))
            read_actions.append(_action("modelTemplates", modelName=model_name))
            read_actions.append(_action("modelFieldDescriptions", modelName=model_name))
            read_actions.append(_action("modelFieldFonts", modelName=model_name))

        read_results = invoke("multi", actions=read_actions)

        for i, model_name in enumerate(models_to_check):
            base = i * 5
            # modelFieldDescriptions returns a list (positional), zip with field names
            field_names = read_results[base]
            raw_descriptions = read_results[base + 3]
            descriptions = dict(zip(field_names, raw_descriptions))

            model_states[model_name] = {
                "fields": field_names,
                "styling": read_results[base + 1],
                "templates": read_results[base + 2],
                "descriptions": descriptions,
                "fonts": read_results[base + 4],
            }

    # ---- Phase 3: Diff + build action dicts ----
    write_actions: list[dict] = []
    created_models: list[str] = []
    updated_models: list[str] = []

    for model_name in models_to_create:
        write_actions.extend(
            _create_model_actions(model_name, is_cloze="cloze" in model_name.lower())
        )
        created_models.append(model_name)

    for model_name in models_to_check:
        if not _is_model_up_to_date(model_name, model_states[model_name]):
            write_actions.extend(
                _update_model_actions(model_name, model_states[model_name])
            )
            updated_models.append(model_name)

    # ---- Phase 4: Batch-write all changes ----
    if write_actions:
        results = invoke("multi", actions=write_actions)
        errors = [r for r in results if r is not None and isinstance(r, str)]
        if errors:
            raise AnkiConnectError(f"Note type sync errors: {errors}")

        for model_name in created_models:
            logger.info(f"Created note type '{model_name}' in Anki")
        for model_name in updated_models:
            logger.info(f"Updated note type '{model_name}' in Anki")


if __name__ == "__main__":
    ensure_note_types()
