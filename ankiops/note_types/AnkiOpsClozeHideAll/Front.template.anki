<style>
    #_flag {
        visibility: hidden;
    }
</style>

<!-- Anki renders the active cloze here; we use this as a fallback if needed -->
<div id="cloze_rendered" style="display:none;">{{cloze:Hidden Text}}</div>
<div id="hidden_raw" style="display:none;">{{Hidden Text}}</div>
<div id="content_display"></div>

<script>
    (function(){
        var raw = document.getElementById("hidden_raw").innerHTML;
        var rendered = document.getElementById("cloze_rendered").innerHTML;
        var clozePattern = /\{\{c(\d+)::([\s\S]*?)\}\}/g;

        function uniqueIndices(text) {
            var seen = {};
            var indices = [];
            var match;
            var idxRegex = /\{\{c(\d+)::/g;
            while ((match = idxRegex.exec(text)) !== null) {
                var idx = match[1];
                if (!seen[idx]) {
                    seen[idx] = true;
                    indices.push(idx);
                }
            }
            return indices;
        }

        function parseInner(inner) {
            var hintPos = inner.indexOf("::");
            if (hintPos === -1) {
                return { content: inner, hint: "" };
            }
            return {
                content: inner.slice(0, hintPos),
                hint: inner.slice(hintPos + 2)
            };
        }

        function normalizeSignature(html) {
            var root = document.createElement("div");
            root.innerHTML = html;

            function walk(node, inCloze) {
                if (node.nodeType === 3) {
                    return node.nodeValue;
                }
                if (node.nodeType !== 1) {
                    return "";
                }

                if (node.tagName === "BR") {
                    return "\n";
                }

                var nextInCloze =
                    inCloze || /\bcloze\b/.test(node.className || "");
                var out = "";
                for (var childIdx = 0; childIdx < node.childNodes.length; childIdx++) {
                    out += walk(node.childNodes[childIdx], nextInCloze);
                }

                if (!inCloze && /\bcloze\b/.test(node.className || "")) {
                    return "[[CLOZE]]" + out + "[[/CLOZE]]";
                }
                return out;
            }

            var txt = "";
            for (var rootIdx = 0; rootIdx < root.childNodes.length; rootIdx++) {
                txt += walk(root.childNodes[rootIdx], false);
            }
            return txt.replace(/\s+/g, " ").trim();
        }

        function simulateFront(text, activeIdx) {
            return text.replace(clozePattern, function(match, idx, inner) {
                var parsed = parseInner(inner);
                if (idx === activeIdx) {
                    var display = parsed.hint ? "[" + parsed.hint + "]" : "[...]";
                    return "<span class='cloze'>" + display + "</span>";
                }
                return parsed.content;
            });
        }

        function detectActiveIndex(indices) {
            if (!indices.length) {
                return "1";
            }

            // Primary strategy: use Anki's per-card CSS class (card1, card2, ...).
            var classMatch = (document.body.className || "").match(/\bcard(\d+)\b/);
            if (classMatch && indices.indexOf(classMatch[1]) !== -1) {
                return classMatch[1];
            }

            // Fallback for preview contexts: compare structural signatures.
            var renderedSig = normalizeSignature(rendered);
            for (var idxPos = 0; idxPos < indices.length; idxPos++) {
                var idx = indices[idxPos];
                var simulatedSig = normalizeSignature(simulateFront(raw, idx));
                if (simulatedSig === renderedSig) {
                    return idx;
                }
            }

            return indices[0];
        }

        var clozeIndices = uniqueIndices(raw);
        var activeIdx = detectActiveIndex(clozeIndices);

        // Render with detected active index
        var result = raw.replace(clozePattern, function(match, idx, inner) {
            var parsed = parseInner(inner);
            if (idx === activeIdx) {
                var displayTxt = parsed.hint ? "[" + parsed.hint + "]" : "[...]";
                return "<span class='cloze'>" + displayTxt + "</span>";
            }
            return "<span class='inactive-cloze' aria-label='hidden cloze'></span>";
        });

        document.getElementById("content_display").innerHTML = result;
    })();
</script>
